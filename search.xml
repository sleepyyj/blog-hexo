<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[HTML5 postMessage解决跨域、跨窗口消息传递]]></title>
      <url>/2017/09/19/postMessage%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E3%80%81%E8%B7%A8%E7%AA%97%E5%8F%A3%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/</url>
      <content type="html"><![CDATA[<h3 id="一些麻烦事儿"><a href="#一些麻烦事儿" class="headerlink" title="一些麻烦事儿"></a>一些麻烦事儿</h3><p>平时做web开发的时候关于消息传递，除了客户端与服务器传值还有几个经常会遇到的问题</p>
<p>1.页面和其打开的新窗口的数据传递</p>
<p>2.多窗口之间消息传递</p>
<p>3.页面与嵌套的iframe消息传递</p>
<p>4.上面三个问题的跨域数据传递</p>
<h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage()"></a>postMessage()</h3><p>这些问题都有一些解决办法，但html5引入的message的API可以更方便、有效、安全的解决这些难题。postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>
<p><code>postMessage(data,origin)</code>方法接受两个参数</p>
<p>1.data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。</p>
<p>2.origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<p><a href="http://test.com/index.html" target="_blank" rel="external">http://test.com/index.html</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:200px; float:left; margin-right:200px;border:solid 1px #333;"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"color"</span>&gt;</span>Frame Color<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">src</span>=<span class="string">"http://lsLib.com/lsLib.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们可以在<a href="http://test.com/index.html通过postMessage()方法向跨域的iframe页面http://lsLib.com/lsLib.html传递消息" target="_blank" rel="external">http://test.com/index.html通过postMessage()方法向跨域的iframe页面http://lsLib.com/lsLib.html传递消息</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">'getcolor'</span>,<span class="string">'http://lslib.com'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>test.com上面的页面向lslib.com发送了消息，那么在lslib.com页面上如何接收消息呢，监听window的message事件就可以</p>
<p><a href="http://lslib.com/lslib.html" target="_blank" rel="external">http://lslib.com/lslib.html</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(e.source!=<span class="built_in">window</span>.parent) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">var</span> color=container.style.backgroundColor;</div><div class="line">    <span class="built_in">window</span>.parent.postMessage(color,<span class="string">'*'</span>);</div><div class="line">&#125;,<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>这样我们就可以接收任何窗口传递来的消息了，为了安全起见，我们利用这时候的MessageEvent对象判断了一下消息源,MessageEvent是一个这样的东东</p>
<p>有几个重要属性</p>
<p>1.data：顾名思义，是传递来的message<br>2.source：发送消息的窗口对象<br>3.origin：发送消息窗口的源（协议+主机+端口号）<br>这样就可以接收跨域的消息了，我们还可以发送消息回去，方法类似</p>
<h3 id="简单的demo"><a href="#简单的demo" class="headerlink" title="简单的demo"></a>简单的demo</h3><p>在这个例子中，左边的div会根据右边iframe内div颜色变化而变化</p>
<p><a href="http://test.com/index.html" target="_blank" rel="external">http://test.com/index.html</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Post Message<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:200px; float:left; margin-right:200px;border:solid 1px #333;"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"color"</span>&gt;</span>Frame Color<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">src</span>=<span class="string">"http://lsLib.com/lsLib.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></div><div class="line"><span class="javascript">            <span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">'getcolor'</span>,<span class="string">'http://lslib.com'</span>);</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">var</span> color=e.data;</span></div><div class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'color'</span>).style.backgroundColor=color;</span></div><div class="line"><span class="javascript">        &#125;,<span class="literal">false</span>);</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><a href="http://lslib.com/lslib.html" target="_blank" rel="external">http://lslib.com/lslib.html</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">            html,body&#123;</span></div><div class="line"><span class="css">                <span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></div><div class="line"><span class="css">                <span class="selector-tag">margin</span><span class="selector-pseudo">:0px</span>;</span></div><div class="line"><span class="undefined">            &#125;</span></div><div class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"height:100%;"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">onclick</span>=<span class="string">"changeColor();"</span> <span class="attr">style</span>=<span class="string">"widht:100%; height:100%; background-color:rgb(204, 102, 0);"</span>&gt;</span></div><div class="line">            click to change color</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="keyword">var</span> container=<span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></div><div class="line"><span class="javascript">                <span class="keyword">if</span>(e.source!=<span class="built_in">window</span>.parent) <span class="keyword">return</span>;</span></div><div class="line"><span class="javascript">                <span class="keyword">var</span> color=container.style.backgroundColor;</span></div><div class="line"><span class="javascript">                <span class="built_in">window</span>.parent.postMessage(color,<span class="string">'*'</span>);</span></div><div class="line"><span class="javascript">            &#125;,<span class="literal">false</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">changeColor</span> (<span class="params"></span>) </span>&#123;            </span></div><div class="line"><span class="javascript">                <span class="keyword">var</span> color=container.style.backgroundColor;</span></div><div class="line"><span class="javascript">                <span class="keyword">if</span>(color==<span class="string">'rgb(204, 102, 0)'</span>)&#123;</span></div><div class="line"><span class="javascript">                    color=<span class="string">'rgb(204, 204, 0)'</span>;</span></div><div class="line"><span class="javascript">                &#125;<span class="keyword">else</span>&#123;</span></div><div class="line"><span class="javascript">                    color=<span class="string">'rgb(204,102,0)'</span>;</span></div><div class="line"><span class="undefined">                &#125;</span></div><div class="line"><span class="undefined">                container.style.backgroundColor=color;</span></div><div class="line"><span class="javascript">                <span class="built_in">window</span>.parent.postMessage(color,<span class="string">'*'</span>);</span></div><div class="line"><span class="undefined">            &#125;</span></div><div class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>很简单的用法却解决了大问题，据说Facebook已经在使用了，而且这也是html5另一个API——web workers传递消息的方法，那么它的浏览器兼容性怎么样呢？所谓浏览器兼容性几乎变成了IE几开始支持的问题了。。。不过好消息是跟<code>localStorage</code>一样，IE8+都支持了，只不过有些浏览器的低版本（比如FireFox4.0）并不支持<code>window.onmessage=function(){}</code>这种写法，所以我么最好使用事件绑定的写法，为了兼容IE，也要判断是否支持<code>addEventListener</code>。</p>
]]></content>
      
        <categories>
            
            <category> HTML5 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React中的key]]></title>
      <url>/2017/09/09/React%E4%B8%AD%E7%9A%84key/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间做一个功能，是基于React的，大家的都知道只要props和state发生变化，React会调用render重新渲染ui。但本例中明明改变了state，UI却没有重新render，查了一下发现和key有关。</p>
<p>大家在使用React的过程中，当组件的子元素是一系列类型相同元素时，就必须添加一个属性key,否则React将给出一个warning:</p>
<p><img src="https://raw.githubusercontent.com/sleepyyj/learngit/master/images/warning.png" alt="warning" title="warning"></p>
<p>所以我们需要了解一下key值在React中起到了什么作用，在这之前我们先出一个小题目: 　　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;ul&gt;</div><div class="line">            &#123;</div><div class="line">                [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>].map(<span class="function">(<span class="params">val</span>)=&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;val&#125;</span>&gt;</span>&#123;val&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)</div><div class="line">            &#125;</div><div class="line">        &lt;<span class="regexp">/ul&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">ReactDOM.render(&lt;App/</span>&gt;,<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</div></pre></td></tr></table></figure>
<p>现在要提问了，上面的例子显示的是: 1,1,2,2还是1,2呢。事实上显示的只有1和2，所以我们不禁要问为什么?</p>
<h3 id="一致性处理-Reconciliation"><a href="#一致性处理-Reconciliation" class="headerlink" title="一致性处理(Reconciliation)　　"></a>一致性处理(Reconciliation)　　</h3><p>我们知道每当组件的props和state发送改变时，React都会调用render去重新渲染UI，实质上render函数作用就是返回最新的元素树。这里我们要明确一个点: 什么是组件？什么是元素?<br>　　<br>React元素是用来描述UI对象的，JSX的实质就是<code>React.createElement</code>的语法糖，作用就是生成React元素。而React组件是一个方法或者类(Class)，其目的就是接受输入并返回一个ReactElement，当然调用React组件一般采用的也是通过JSX的方法，其本质也是通过React.createElement方式去调用组件的。<br>　　<br>我们之前说过，组件<code>state</code>和<code>props</code>的改变会引起render函数的调用，而render函数会返回新的元素树。我们知道React使得我们并不需要关心更改的内容，只需要将精力集中于数据的变化，React会负责前后UI更新。这时候React就面临一个问题，如果对比当前的元素树与之前的元素树，从而找到最优的方法(或者说是步骤最少的方法)将一颗树转化成另一棵树，从而去更新真实的DOM元素。目前存在大量的方法可以将一棵树转化成另一棵树，但它们的时间复杂度基本都是O(n3),这么庞大的时间数量级我们是不能接受的，试想如果我们的组件返回的元素树中含有100个元素，那么一次一致性比较就要达到1000000的数量级，这显然是低效的，不可接受的。这时React就采用了启发式的算法。 　　</p>
<h3 id="启发式算法"><a href="#启发式算法" class="headerlink" title="启发式算法"></a>启发式算法</h3><p>了解一下什么是启发式算法：</p>
<blockquote>
<p>启发式算法指人在解决问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时,利用过去的经验,选择已经行之有效的方法，而不是系统地、以确定的步骤去寻求答案。</p>
</blockquote>
<p>React启发式算法就是采用一系列前提和假设，使得比较前后元素树的时间复杂度由O(n3)降低为O(n)，React启发式算法的前提条件主要包括两点:</p>
<p>1.不同的两个元素会产生不同的树<br>2.可以使用key属性来表明不同的渲染中哪些元素是相同的</p>
<h3 id="元素类型的比较"><a href="#元素类型的比较" class="headerlink" title="元素类型的比较"></a>元素类型的比较</h3><p>函数<code>React.createElement</code>的第一个参数就是type，表示的就是元素的类型。React比较两棵元素树的过程是同步的，当React比较到元素树中同一位置的元素节点时，如果前后元素的类型不同时,不论该元素是组件类型还是DOM类型的，那么以这个节点(React元素)为子树的所有节点都会被销毁并重新构建。举个例子: 　　</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//old tree</div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">//new tree</div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面表示前后两个render函数返回的元素树，由于<code>Counter</code>元素的父元素由<code>div</code>变成了<code>span</code>，那么那就导致<code>Counter</code>的卸载<code>(unmount)</code>和重新安装<code>(mount)</code>。这看起来没有什么问题，但是在某些情况下问题就会凸显出来，比如状态的丢失。下面我们再看一个例子: 　　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">    &#125;</div><div class="line">    state = &#123;</div><div class="line">        value: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    componentWillMount()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'componentWillMount'</span>);</div><div class="line">    &#125;</div><div class="line">    componentDidMount()&#123;</div><div class="line">        <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                value: <span class="keyword">this</span>.state.value + <span class="number">1</span></div><div class="line">            &#125;)</div><div class="line">        &#125;,<span class="number">1000</span>)</div><div class="line">    &#125;</div><div class="line">    componentWillUnmount()&#123;</div><div class="line">        clearInterval(<span class="keyword">this</span>.timer);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount'</span>);</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span>(</div><div class="line">            &lt;div&gt;&#123;<span class="keyword">this</span>.state.value&#125;&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        )</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">function Demo(props) &#123;</span></div><div class="line"><span class="regexp">    return props.flag ? (&lt;div&gt;&lt;Counter/</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>) : (<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">Counter</span>/&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">    &#125;</div><div class="line">    state = &#123;</div><div class="line">        flag: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span>(</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;Demo flag = &#123;<span class="keyword">this</span>.state.flag&#125;/&gt;</div><div class="line">                &lt;button</div><div class="line">                    onClick=&#123;()=&gt;&#123;</div><div class="line">                        <span class="keyword">this</span>.setState(&#123;</div><div class="line">                            flag: !<span class="keyword">this</span>.state.flag</div><div class="line">                        &#125;)</div><div class="line">                    &#125;&#125;</div><div class="line">                &gt;</div><div class="line">                Click</div><div class="line">                &lt;<span class="regexp">/button&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</div></pre></td></tr></table></figure>
<p>上面的例子中，我们首先让计数器<code>Counter</code>运行几秒钟，然后我们点击按钮的话，我们会发现计数器的值会归零为0，并且<code>Counter</code>分别调用<code>componentWillUnmount</code>与<code>componentWillMount</code>并完成组件卸载与安装的过程。需要注意的是，状态<code>(state)</code>的丢失有时候会造成不可预知的问题，需要尤为注意。</p>
<h3 id="key属性"><a href="#key属性" class="headerlink" title="key属性"></a>key属性</h3><p>在上面的前后元素树比较过程中，如果某个元素的子元素是动态数组类型的，那么比较的过程可能就要有所区分，比如: 　　</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//注意:</div><div class="line">//li元素是数组生成的，下面只是表示元素树，并不代表实际代码</div><div class="line">//old tree</div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line">//new tree</div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当React同时迭代比较前后两棵元素树的子元素列表时，性能相对不会太差，因为前两个项都是相同的，新的元素树中有第三个项目，那么React会比较<code>&lt;li&gt;first&lt;/li&gt;</code>树与<code>&lt;li&gt;second&lt;/li&gt;</code>树之后，插入<code>&lt;li&gt;third&lt;/li&gt;</code>树，但是下面这个例子就不同的: 　　</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//注意:</div><div class="line">//li元素是数组生成的，下面只是表示元素树，并不代表实际代码</div><div class="line">//old tree</div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line">//new tree</div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>React在比较第一个li就发现了差异(<code>&lt;li&gt;Duke&lt;/li&gt;与&lt;li&gt;Connecticut&lt;/li&gt;</code>)，如果React将第一个li中的内容进行更新，那么你会发现第二个li(<code>&lt;li&gt;Villanova&lt;/li&gt;</code>与<code>&lt;li&gt;Duke&lt;/li&gt;</code>)也需要将li中内容进行更新，并且第三个<code>&lt;li&gt;</code>需要安装新的元素，但事实真的是如此吗？其实不然，我们发现新的元素树和旧的元素树，只有第一项是不同的，后两项其实并没有发生改变，如果React懂得在旧的元素树开始出插入<code>&lt;li&gt;Connecticut&lt;/li&gt;</code>，那么性能会极大的提高，关键问题是React如何进行这种判别，这时React就用到了key属性。</p>
<p>例如:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//注意:</div><div class="line">//li元素是数组生成的，下面只是表示元素树，并不代表实际代码</div><div class="line">//old tree</div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2015"</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2016"</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line">//new tree</div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2014"</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2015"</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2016"</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>通过key值React比较<code>&lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;</code>与<code>&lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt;</code>时，会发现key值是不同，表示<code>&lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt;</code>是新插入的项，因此会在开始出插入<code>&lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt;</code>,随后分别比较<code>&lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;</code>与<code>&lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;</code>,发现<code>li</code>项没有发生改变，仅仅只是被移动而已。这种情况下，性能的提升是非常可观的。因此，从上面看key值必须要稳定、可预测的并且是唯一的。不稳定的key(类似于<code>Math.random()</code>函数的结果)可能会产生非常多的组件实例并且DOM节点也会非必要性的重新创建。这将会造成极大的性能损失和组件内state的丢失。<br>　　<br>回到刚开始的问题，如果存在两个key值相同时，会发生什么？比如: 　　</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    &#123;</div><div class="line">        [1,1,2,2].map((val)=&gt;<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;val&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们会发现如果存在前后两个相同的key，React会认为这两个元素其实是一个元素，后一个具有相同key值的元素会被忽略。为了验证这个事实，我们可以看下一个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;&#123;props.value&#125;&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">class App extends Component &#123;</span></div><div class="line"><span class="regexp">    constructor(props) &#123;</span></div><div class="line"><span class="regexp">        super(props);</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">    render() &#123;</span></div><div class="line"><span class="regexp">        return (</span></div><div class="line"><span class="regexp">            &lt;div&gt;</span></div><div class="line"><span class="regexp">                &#123;</span></div><div class="line"><span class="regexp">                    [1, 1, 2, 2].map((val, index) =&gt; &#123;</span></div><div class="line"><span class="regexp">                        return (</span></div><div class="line"><span class="regexp">                            &lt;Demo</span></div><div class="line"><span class="regexp">                                key=&#123;val&#125;</span></div><div class="line"><span class="regexp">                                value=&#123;val + '-' + index&#125;</span></div><div class="line"><span class="regexp">                            /</span>&gt;</div><div class="line">                        )</div><div class="line">                    &#125;)</div><div class="line">                &#125;</div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        )</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">ReactDOM.render(&lt;App/</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</div></pre></td></tr></table></figure>
<p>我们发现最后的显示效果是这样的:</p>
<blockquote>
<p>1-0<br>2-2</p>
</blockquote>
<p>到这里我们已经基本明白了key属性在React中的作用，因为key是React内部使用的属性，所以在组件内部是无法获取到key值的，如果你真的需要这个值，就需要换个名字再传一次了。<br>　　<br>其实还有一个现象不知道大家观察到了没有，比如: 　　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//case1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;ul&gt;</div><div class="line">            &#123;</div><div class="line">                [</div><div class="line">                    &lt;li key=&#123;<span class="number">1</span>&#125;&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;,</span></div><div class="line"><span class="regexp">                    &lt;li key=&#123;2&#125;&gt;2&lt;/</span>li&gt;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        &lt;<span class="regexp">/ul&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/case2</span></div><div class="line"><span class="regexp">function App() &#123;</span></div><div class="line"><span class="regexp">    return (</span></div><div class="line"><span class="regexp">        &lt;ul&gt;</span></div><div class="line"><span class="regexp">            &lt;li&gt;1&lt;/</span>li&gt;</div><div class="line">            &lt;li&gt;<span class="number">2</span>&lt;<span class="regexp">/li&gt;</span></div><div class="line"><span class="regexp">        &lt;/u</span>l&gt;</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们会发现，第一种场景是需要传入key值的，第二种就不需要传入key，为什么呢？其实我们可以看一下JSX编译之后的代码: 　　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//case1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> React.createElement(<span class="string">'ul'</span>,<span class="literal">null</span>,[</div><div class="line">        React.createElement(<span class="string">'li'</span>,&#123;<span class="attr">key</span>: <span class="number">1</span>&#125;, <span class="string">"1"</span>),</div><div class="line">        React.createElement(<span class="string">'li'</span>,&#123;<span class="attr">key</span>: <span class="number">2</span>&#125;, <span class="string">"2"</span>)</div><div class="line">    ])</div><div class="line">&#125;</div><div class="line"><span class="comment">//case2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> React.createElement(<span class="string">'ul'</span>,</div><div class="line">        <span class="literal">null</span>,</div><div class="line">        React.createElement(<span class="string">'li'</span>,&#123;<span class="attr">key</span>: <span class="number">1</span>&#125;, <span class="string">"1"</span>),</div><div class="line">        React.createElement(<span class="string">'li'</span>,&#123;<span class="attr">key</span>: <span class="number">2</span>&#125;, <span class="string">"2"</span>)</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现第一个场景中，子元素的传入<strong>以数组的形式</strong>传入第三个参数，但是在第二个场景中，子元素是以参数的形式依次传入的。在第二种场景中，每个元素出现在固定的参数位置上，React就是通过这个位置作为天然的key值去判别的，所以你就不用传入key值的，但是第一种场景下，以数组的类型将全部子元素传入，React就不能通过参数位置的方法去判别，所以就必须你手动地方式去传入key值。</p>
]]></content>
      
        <categories>
            
            <category> React </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack之babel-loader配置]]></title>
      <url>/2017/09/07/webpack%E4%B9%8Bbabel-loader%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端知识体系真滴庞大，光打包工具就有好多，gulp、grunt、webpack、Yeoman、bower等等。前段时间看到一个stage属性，查了下资料，这里顺便写一写babel-loader相关的知识。</p>
<h3 id="babel-loader配置"><a href="#babel-loader配置" class="headerlink" title="babel-loader配置"></a>babel-loader配置</h3><p>babel是一个转换器，可以把JSX和ES6代码转换成普通js文件和es5代码，因为现在主流的JavaScript对es6的支持并不高，而且没有浏览器支持jsx，所以如果你想使用es6的一颗赛艇的新特性，babel是必要的。贴段代码吧</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">  loaders: [</div><div class="line">    &#123;</div><div class="line">        test: /\.jsx?$/, // A regexp to test the require path. accepts either js or jsx</div><div class="line">        exclude: /(node_modules|bower_components)/,</div><div class="line">        loader: 'babel', </div><div class="line">        query: &#123;</div><div class="line">            "presets": [</div><div class="line">        "react",</div><div class="line">        "es2015",</div><div class="line">        "stage-1"</div><div class="line">        ],</div><div class="line">            "plugins": ["transform-decorators-legacy"]</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）<br>exclude：屏蔽不需要处理的文件（文件夹）（可选）<br>loader：loader的名称（必须）<br>query：为loaders提供额外的设置选项（可选），也可以写在loader选项babel的后面，如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">  loaders: [</div><div class="line">    &#123;</div><div class="line">		test: /\.jsx?$/, // A regexp to test the require path. accepts either js or jsx</div><div class="line">		exclude: /(node_modules|bower_components)/,</div><div class="line">		loader: 'babel?presets[]=es2015&amp;presets[]=react&amp;presets[]=stage-1', </div><div class="line">		query: &#123;</div><div class="line">      		"plugins": ["transform-decorators-legacy"] //这个插件下面会讲到</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>敲黑板。下面重点讲一下stage</p>
<h3 id="stage-0"><a href="#stage-0" class="headerlink" title="stage-0"></a>stage-0</h3><p>stage-0包含stage-1, stage-2以及stage-3的所有功能，同时还另外支持如下两个功能插件：</p>
<ul>
<li>transform-do-expressions 这个插件就是为了方便在 jsx写if/else表达式而提出的，我们可以在return中写if/else，虽然很牛逼，但是好像没啥意义，写render里就行了嘛…</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> App = React.createClass(&#123;</div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">let</span> &#123; color &#125; = <span class="keyword">this</span>.props;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div className=<span class="string">"parents"</span>&gt;</div><div class="line">                &#123;<span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span>(color == <span class="string">'blue'</span>) &#123; </div><div class="line">                        &lt;BlueComponent/&gt; </div><div class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color == <span class="string">'red'</span>) &#123; </div><div class="line">                        &lt;RedComponent/&gt; </div><div class="line">                    &#125;<span class="keyword">else</span> &#123; </div><div class="line">                        &lt;GreenComponent/&gt; &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;&#125;</div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        )</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;)</span></div></pre></td></tr></table></figure>
<ul>
<li>transform-function-bind 这个插件其实就是提供过 :: 这个操作符来方便快速切换上下文，看代码吧，这个我也没看懂</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">obj::func</div><div class="line"><span class="comment">// is equivalent to:</span></div><div class="line">func.bind(obj)</div><div class="line"></div><div class="line">obj::func(val)</div><div class="line"><span class="comment">// is equivalent to:</span></div><div class="line">func.call(obj, val)</div><div class="line"></div><div class="line">::obj.func(val)</div><div class="line"><span class="comment">// is equivalent to:</span></div><div class="line">func.call(obj, val)</div><div class="line"></div><div class="line"><span class="comment">// 再来一个复杂点的样例</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> box = &#123;</div><div class="line">  weight: <span class="number">2</span>,</div><div class="line">  getWeight() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.weight; &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; getWeight &#125; = box;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(box.getWeight()); <span class="comment">// prints '2'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> bigBox = &#123; <span class="attr">weight</span>: <span class="number">10</span> &#125;;</div><div class="line"><span class="built_in">console</span>.log(bigBox::getWeight()); <span class="comment">// prints '10'</span></div><div class="line"></div><div class="line"><span class="comment">// Can be chained:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">val</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span> + val; &#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(bigBox::getWeight()::add(<span class="number">5</span>)); <span class="comment">// prints '15'</span></div></pre></td></tr></table></figure>
<h3 id="stage-1"><a href="#stage-1" class="headerlink" title="stage-1"></a>stage-1</h3><p>stage-1除了包含stage-2和stage-3，还包含了下面2个插件：﻿</p>
<ul>
<li>transform-class-properties 官方文档中这个插件已经被废弃</li>
<li>transform-export-extensions 对不起，我也不知道这个是干嘛的，官方文档也没有解释…</li>
</ul>
<h3 id="stage-2"><a href="#stage-2" class="headerlink" title="stage-2"></a>stage-2</h3><p>它除了覆盖stage-3的所有功能，还支持如下两个插件：</p>
<ul>
<li>syntax-trailing-function-commas 尾逗号函数，这个就不贴代码了，就是在数组或对象的最后一个元素的后面加逗号不会报错，很实用</li>
<li>transform-object-reset-spread 其实它是对 ES6中解构赋值的一个扩展，因为ES6只支持对数组的解构赋值，对对象是不支持的。如下面的代码所示：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取剩下的属性</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(y); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(z); <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 属性展开</span></div><div class="line"><span class="keyword">let</span> n = &#123; x, y, ...z &#125;;</div><div class="line"><span class="built_in">console</span>.log(n); <span class="comment">// &#123; x: 1, y: 2, a: 3, b: 4 &#125;</span></div></pre></td></tr></table></figure>
<h3 id="stage-3"><a href="#stage-3" class="headerlink" title="stage-3"></a>stage-3</h3><p>它支持大名鼎鼎的async和await, 这两个哥们可是解决(Ajax)回调函数的终极解决方法呀！管你什么异步，我都可以用同步的思维来写，ES7里面非常强悍的存在。总的来说，它包含如下两个插件:</p>
<ul>
<li>transform-async-to-generator 主要用来支持ES7中的async和await</li>
<li>transform-exponentiation-operator<br>transform-exponentiation-operator这个插件算是一个语法糖，可以通过**这个符号来进行幂操作，想当于Math.pow(a,b)。如下面的样例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// x ** y</span></div><div class="line"><span class="keyword">let</span> squared = <span class="number">2</span> ** <span class="number">2</span>;</div><div class="line"><span class="comment">// 相当于: 2 * 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> cubed = <span class="number">2</span> ** <span class="number">3</span>;</div><div class="line"><span class="comment">// 相当于: 2 * 2 * 2</span></div><div class="line"></div><div class="line"><span class="comment">// x **= y</span></div><div class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</div><div class="line">a **= <span class="number">2</span>;</div><div class="line"><span class="comment">// 相当于: a = a * a;</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</div><div class="line">b **= <span class="number">3</span>;</div><div class="line"><span class="comment">// 相当于: b = b * b * b;</span></div></pre></td></tr></table></figure>
<p>如果分不清stage-0、stage-1、stage-2、stage-3区别，请写上stage-0，就能嗨起来了…放心的使用es6和es7的新特性。</p>
]]></content>
      
        <categories>
            
            <category> webpack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS实现全屏的一些坑]]></title>
      <url>/2017/08/29/JS%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两天做了一个pdf全屏播放的功能，以为看看API就能完成的，没想到因为一个keydown的问题浪费了大半天。</p>
<h3 id="先看下API"><a href="#先看下API" class="headerlink" title="先看下API"></a>先看下API</h3><p><code>Document.fullscreen</code>：检测当前页面是否全屏<br><code>Document.fullscreenEnabled</code>：当前页面是否允许全屏<br><code>Document.fullscreenElement</code>：输出当前的全屏的元素<br><code>Document.onfullscreenchange</code>：在exitFullscreen和requestFullscreen的时候会触发<br><code>Document.onfullscreenerror</code>：全屏事件出现错误时进行一些操作<br><code>Document.exitFullscreen()</code>：手动退出全屏<br><code>Element.requestFullscreen()</code>：手动进入全屏</p>
<p>使用的时候需要加上浏览器前缀</p>
<h3 id="requestFullscreen"><a href="#requestFullscreen" class="headerlink" title="requestFullscreen()"></a>requestFullscreen()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(element.requestFullscreen) &#123;</div><div class="line">    element.requestFullscreen();</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.mozRequestFullScreen) &#123;</div><div class="line">    element.mozRequestFullScreen();</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.msRequestFullscreen)&#123;</div><div class="line">    element.msRequestFullscreen();</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.webkitRequestFullscreen) &#123;</div><div class="line">    element.webkitRequestFullScreen();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意；全屏窗口不可滚动查看内容，全屏元素需加width: 100%;height: 100%;overflow: auto; 控制 ，以达到各浏览器显示效果一致（注：Gecko 会为元素自动添加 CSS 使其伸展以便铺满屏幕： “width: 100%; height: 100%”。 WebKit 则不会这么做；它会让全屏的元素以原始尺寸居中到屏幕中央，其余部分变为黑色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:-webkit-full-screen</span>&#123;</div><div class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#11ee11</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有全屏化的祖先元素样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:fullscreen-ancestor</span>&#123;</div><div class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进入全屏标准写法requestFullscreen中的screen单词首字母是小写s，ms只需加上各自的浏览器前缀即可，但firefox和chrome除了加前缀screen单词首个字母必须大写：mozRequestFullScreen() webkitRequestFullScreen()</p>
<h3 id="exitFullscreen"><a href="#exitFullscreen" class="headerlink" title="exitFullscreen()"></a>exitFullscreen()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.exitFullscreen) &#123;</div><div class="line">    <span class="built_in">document</span>.exitFullscreen();</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.msExitFullscreen) &#123;</div><div class="line">    <span class="built_in">document</span>.msExitFullscreen();</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.mozCancelFullScreen) &#123;</div><div class="line">    <span class="built_in">document</span>.mozCancelFullScreen();</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.webkitExitFullscreen) &#123;</div><div class="line">    <span class="built_in">document</span>.webkitExitFullscreen();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用户手动按下ESC键或F11键，也可以退出全屏键。此外，加载新的页面，或者切换tab，或者从浏览器转向其他应用（按下Alt-Tab），也会导致退出全屏状态。<br>最坑的就是在Chrome下，按esc不会退出全屏，而且给esc加keydown事件手动去触发exitFullscreen也不行。最后把事件绑在了x和F11上，另一种解决方法就是在全屏界面上悬浮一个退出全屏的按钮，去调用exitFullscreen，这样好像比较舒服一点。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ow</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(p)&#123;</div><div class="line">        <span class="keyword">super</span>(p)</div><div class="line">        <span class="keyword">this</span>._name = <span class="keyword">this</span>.props.__name.replace(<span class="string">".aliyuncs.com"</span>,<span class="string">"-internal.aliyuncs.com"</span>)</div><div class="line">    &#125;</div><div class="line">    exitFullScreen=<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">        <span class="built_in">document</span>.webkitCancelFullScreen()</div><div class="line">    &#125;</div><div class="line">    load=<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">        <span class="keyword">var</span> doc = <span class="keyword">this</span>._d.contentWindow.document</div><div class="line">        doc.addEventListener(<span class="string">"keydown"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">            <span class="keyword">if</span> (e.key == <span class="string">"F11"</span> || e.key == <span class="string">"x"</span>) &#123;</div><div class="line">                <span class="built_in">document</span>.webkitCancelFullScreen()</div><div class="line">                Plaso.hideTop()</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    componentDidMount()&#123;</div><div class="line">        <span class="keyword">var</span> d = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>]</div><div class="line">        <span class="keyword">this</span>._d=d</div><div class="line">        d.webkitRequestFullScreen()</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">var</span> props=<span class="keyword">this</span>.props</div><div class="line">        <span class="keyword">var</span> path=<span class="string">""</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div className=&#123;lcns([<span class="string">"border"</span>])&#125;&gt;</div><div class="line">                &lt;div className=&#123;lcns([<span class="string">"exit"</span>])&#125; onClick=&#123;<span class="keyword">this</span>.exitFullScreen&#125;&gt;退出全屏&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">                &lt;iframe className=&#123;lcns(["iframe"])&#125; src=&#123;path&#125; allowFullScreen="true" onLoad=&#123;this.load&#125;/</span>&gt;</div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">module.exports=ow</span></div></pre></td></tr></table></figure>
<p><strong>有几个注意点</strong><br>1、我这边要全屏的元素是iframe，所以记得加上<code>allowFullScreen=&quot;true&quot;</code><br>2、keydown事件在iframe加载完之后再绑定，写在componentDidMount里面是没有用的，要写在iframe的onload里面<br>3、keydown事件要绑在iframe的document上（contentWindow.document），而不是外层的document</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API" title="Fullscreen_API" target="_blank" rel="external">Fullscreen_API</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git：世界上最好的版本控制工具]]></title>
      <url>/2017/08/26/Git%EF%BC%9A%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年用的是SVN，换了家公司用了git，没有对比就没有伤害，不得不承认git是世界上最好的版本控制工具。本文记下常用的git命令，内容大多参考廖雪峰老师的git教程。加上自己工作中用到的一些命令。这里就不介绍工作区、暂存区、版本库和远程库的概念了。</p>
<h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><ul>
<li>初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： <ul>
<li>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件； </li>
<li>第二步，使用命令<code>git commit</code>，完成。</li>
</ul>
</li>
<li>要随时掌握工作区的状态，使用<code>git status</code>命令。 </li>
<li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li>
</ul>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。<br>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
<li>每次修改，如果不add到暂存区，那就不会加入到commit中。<ul>
<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</li>
<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li>
</ul>
</li>
<li>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</li>
</ul>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li>要关联一个远程库，使用命<code>令git remote add origin git@server-name:path/repo-name.git</code>；</li>
<li>关联后，使用命令<code>git push -u origin master第一次推送master分支的所有内容</code>；</li>
<li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</li>
<li>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。<br>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</li>
</ul>
<h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>Git鼓励大量使用分支：<br>查看分支：<code>git branch</code><br>创建分支：<code>git branch &lt;name&gt;</code><br>切换分支：<code>git checkout &lt;name&gt;</code><br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code><br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code><br>删除分支：<code>git branch -d &lt;name&gt;</code><br>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>用<code>git log --grap</code>h命令可以看到分支合并图。<br>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<h3 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h3><ul>
<li>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</li>
<li>用<code>git stash list</code>命令看看，工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：<br>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；<br>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</li>
</ul>
<h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><p>开发一个新feature，最好新建一个分支；<br>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h3 id="多人合作"><a href="#多人合作" class="headerlink" title="多人合作"></a>多人合作</h3><p>多人协作的工作模式通常是这样：<br>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改，如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并，如果合并有冲突，则解决冲突，并在本地提交，没有冲突或者解决掉冲突后，再用<code>git push origin branch-name</code>推送就能成功！<br>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p><code>git tag &lt;name&gt;</code>：用于新建一个标签，默认为HEAD，也可以指定一个commit id；<br><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>：可以指定标签信息；<br><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>：可以用PGP签名标签；<br><code>git tag</code>：可以查看所有标签。<br><code>git push origin &lt;tagname&gt;</code>：可以推送一个本地标签；<br><code>git push origin --tags</code>：可以推送全部未推送过的本地标签；<br><code>git tag -d &lt;tagname&gt;</code>：可以删除一个本地标签；<br><code>git push origin :refs/tags/&lt;tagname&gt;</code>：可以删除一个远程标签。</p>
<h3 id="贴一份常用命令的别名"><a href="#贴一份常用命令的别名" class="headerlink" title="贴一份常用命令的别名"></a>贴一份常用命令的别名</h3><p><img src="https://raw.githubusercontent.com/sleepyyj/learngit/master/images/gitalias.png" alt="git alias" title="git alias"></p>
<h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><ul>
<li>项目中可能会用到一些通用的模块，可以提取出来作为一个单独的project被多个项目公用。使用<code>git submodule add</code>将一个外部项目添加为子模块。如果想从远程库拉一个带子模块的项目，clone之后会发现子模块的目录是空的。这时候先运行<code>git submodule init</code>初始化本地的配置文件，<code>git submodule update</code>拉取子模块的数据到本地。</li>
<li>需要注意的是，每次在子模块中add、commmit、push后回到上层模块，<code>git status</code>看一下会发现子模块有new commits，这时要在层模块再来一套add、commit、push，否则多人协作时，他人无法知道你修改了子模块。同理，其他人需要同步你提交的代码，在pull完之后运行<code>git submodule update</code>即可。</li>
<li>特别注意：如果没有在子模块中push，而在上层模块push的话，在上层模块<code>git status</code>显示的是 modify content而不是new commits。这种情况下，其他人<code>git submodule update</code>的时候会报错，提示找不到那个子模块的commit id，那是肯定的，因为你并没有在子模块中push。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sleepyyj/learngit/master/images/nocommitid.png" alt="no commit id" title="no commit id"></p>
<h3 id="git-merge和git-rebase的区别"><a href="#git-merge和git-rebase的区别" class="headerlink" title="git merge和git rebase的区别"></a>git merge和git rebase的区别</h3><p>这篇文章总结的不错，懒得写了。。。我们公司一般用rebase，rebase让树看起来比较干净。<br><a href="http://blog.csdn.net/wh_19910525/article/details/7554489" target="_blank" rel="external">http://blog.csdn.net/wh_19910525/article/details/7554489</a></p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[经验]]></title>
      <url>/2017/08/25/%E7%BB%8F%E9%AA%8C/</url>
      <content type="html"><![CDATA[<ul>
<li><p>flex-grow的元素会把普通元素的大小压缩，给不想被压缩 的元素设置flex-shrink:0</p>
</li>
<li><p>background-attachment:local 不生效的时候加个border-radius:1px</p>
</li>
<li><p>FormData 文件的data要放在普通表单data的后面 否则后台无法获取req.body.普通表单值</p>
</li>
<li><p>pointer-events: none; 永远不会成为鼠标事件的 target ，但可以指向其后代元素</p>
</li>
<li><p>函数提升优先级比变量提升要高，且不会被变量声明覆盖，但是会被变量赋值覆盖，所以你上面的代码实际上是</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">functionfoo()&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"函数声明"</span>);</div><div class="line">&#125;</div><div class="line">varfoo;</div><div class="line"><span class="built_in">console</span>.log(foo);</div><div class="line">foo=<span class="string">"变量"</span>;</div></pre></td></tr></table></figure>
<p>在最后再加上打印就能看到函数已经被覆盖了。<br>注：初始化变量不会把值也提上上去，只会提升变量的声明。</p>
<ul>
<li><p>file.delete() 之前要先关闭流 否则删除失败</p>
</li>
<li><p>未明确定义列：不要使用select * ，select具体的字段</p>
</li>
<li><p>mongoose.model(“”,Scheme,””) 第一个参数是废的 第三个参数指定 collection 名字<br>mongoose.set(‘pluralization’, false) 阻止mongoose寻找复数形式的collection 比如：person会去找people</p>
</li>
<li><p>month: { $month: { $add: [new Date(0), “$beginTime”] } } 用毫秒获取年月日</p>
</li>
<li><p>model.update() 要么写回调要么用yield 否则不执行…</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 经验 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[oracle rownum]]></title>
      <url>/2017/04/07/oracle-rownum/</url>
      <content type="html"><![CDATA[<p>由于ROWNUM是一个伪列，只有有结果记录时，ROWNUM才有相应数据，因此对它的使用不能向普通列那样使用，否则就会陷入一些“陷阱”当中。<br>不能对ROWNUM使用&gt;（大于1的数值）、&gt;=（大于或等于1的数值）、=（大于或等于1的数值），否则无结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">selectcount(*)fromcss_bl_viewawhererownum&gt;0;COUNT(*)----------361928</div><div class="line">selectcount(*)fromcss_bl_viewawhererownum&gt;1;COUNT(*)----------0</div></pre></td></tr></table></figure>
<p>这是因为：<br>1、ROWNUM是伪列，必须要要有返回结果后，每条返回记录就会对应产生一个ROWNUM数值；<br>2、返回结果记录的ROWNUM是从1开始排序的，因此第一条始终是1;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select count(*)  from  (select BL_REF_CDE, rownum rn from css_bl_view) where rn &gt; 1;   COUNT(*)----------361927</div></pre></td></tr></table></figure>
<p>这样，当查询到第一条记录时，该记录的ROWNUM为1，但条件要求ROWNUM&gt;1，因此不符合，继续查询下一条；因为前面没有符合要求的记录，因此下一条记录过来后，其ROWNUM还是为1，如此循环，就不会产生结果。上述查询可以通过子查询来替代：</p>
]]></content>
      
        <categories>
            
            <category> Sql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Sql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[statement和resultset]]></title>
      <url>/2017/03/02/statement%E5%92%8Cresultset/</url>
      <content type="html"><![CDATA[<p>1、Connection 是 Statement 的工厂，一个 Connection 可以生产多个 Statement<br>2、Statement、PreparedStatement 是 ResultSet 的工厂，一个 Statement、PreparedStatement 却只能对应一个 ResultSet（他们是一一对应的关系），<br>      但是同一个 Statement 或 PreparedStatement 可以连续执行 executeUpdate、execute 等，只要不返回 ResultSet。</p>
<p>所以在一段程序里要用多个 ResultSet 的时候，必须在 Connection 中获得多个 Statement，然后一个 Statement 对应一个 ResultSet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);  </div><div class="line">conn=DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@192.168.23.45:1521:ORABI"</span>,<span class="string">"portal"</span>,<span class="string">"portal123"</span>);  </div><div class="line">    </div><div class="line">stmt=conn.createStatement();  </div><div class="line">rs=stmt.executeQuery(sql1);  </div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  </div><div class="line"><span class="keyword">while</span>(rs.next())&#123;  </div><div class="line">    ystem.out.println(<span class="string">"i = "</span>+ i++);  </div><div class="line">    rsProc=stmt.executeQuery(sql1)  </div><div class="line">    <span class="keyword">int</span> j =<span class="number">0</span>;  </div><div class="line">    <span class="keyword">while</span>(rsProc.next())&#123;  </div><div class="line">        System.out.println(<span class="string">"j = "</span>+ j++);  </div><div class="line">    &#125;             </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rs结果集中应该为多条数据，然而rs.next()只能取出集合中的第一条，但是rsProc.next()去记录是正常的。<br> ﻿<br>问题解决的方式：<br>1.新增一个statement对象Statement stmt2=null;<br>2.将rsProc=stmt.executeQuery(sql1);修改如下：<br>   stmt2 = conn.createStatement();<br>   rsProc=stmt2.executeQuery(sql1);<br>3.在finally中添加如下：<br>   if(stmt2!=null){<br>      stmt2.close();<br>   }<br>程序运行就正常了。</p>
<p>经思考之后，原因如下：<br>statement用于执行静态 SQL 语句并返回它所生成结果的对象。在默认情况下，同一时间每个 Statement 对象只能打开一个 ResultSet 对象(既同一个Statement打开的ResultSet只有一个记录指针)。因此创建SQL statement在执行sql中的流程，如果读取一个 ResultSet 对象与读取另一个交叉，则这两个对象必须是由不同的 Statement 对象生成的。如果存在某个语句的打开的了前 ResultSet 对象，则Statement 接口中的所有执行方法都会隐式关闭它。这里的ResultSet对象是默认的， ResultSet 对象不可更新，仅有一个向前移动的指针。因此，只能迭代它一次，并且只能按从第一行到最后一行的顺序进行。可以生成可滚动和/或可更新的 ResultSet 对象。以下代码片段（其中 con 为有效的 Connection 对象）演示了如何生成可滚动且不受其他更新影响的、可更新的结果集。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Statement stmt = con.createStatement(</div><div class="line">                               ResultSet.TYPE_SCROLL_INSENSITIVE,</div><div class="line">                               ResultSet.CONCUR_UPDATABLE);</div><div class="line">ResultSet rs = stmt.executeQuery(<span class="string">"SELECT a, b FROM TABLE2"</span>);</div></pre></td></tr></table></figure></p>
<p>修改前的rsProc=stmt.executeQuery(sql1);中stmt并没有重新创建，因此rsProc对象地址没有发生变化。在rsProc循环取记录的之后，对象中的指示记录的指针已经指向结果集尾部，因而结果集rs再次next（）的时候返回的是false，即只取出结果的第一条记录。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[There is no getter for property named 'id' in 'class java.lang.Integer']]></title>
      <url>/2017/01/12/There-is-no-getter-for-property-named-id-in-class-java-lang-Integer/</url>
      <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></div><div class="line">    select * from user1 </div><div class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id != null and id != ''"</span>&gt;</span></div><div class="line">            and id=#&#123;id&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在测试时报错：There is no getter for property named ‘id’ in ‘class java.lang.Integer’</p>
<p>问题分析：Mybatis默认采用ONGL解析参数，所以会自动采用对象树的形式取integer.id值，引起报错。</p>
<p>解决方法：  public User findUserById(@Param(“id”)int id);说明参数值。</p>
]]></content>
      
        <categories>
            
            <category> Mybatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQL优化]]></title>
      <url>/2016/12/28/SQL%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><ul>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<br>select id from t where num is null<br>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br>select id from t where num=0</p>
</li>
<li><p>避免Select <em><br>Selcet中每少提取一个字段，数据的提取速度就会有相应的提升。提升的速度还要看您舍弃的字段的大小来判断。应避免使用Select </em>。</p>
</li>
<li><p>表关联顺序<br>Oracle的解析器按照从右到左的顺序处理from子句中的表名，from子句中写在最后的表(基础表 driving table)将被最先处理，在from子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表。</p>
</li>
<li><p>避免全表扫描<br>Where中少用NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、NOT LIKE，它们会引起全表扫描。</p>
</li>
<li><p>用Where子句替代having子句<br>避免使用having子句，having只会在检索出所有记录之后才对结果集进行过滤。</p>
</li>
<li><p>exists代替in<br>Oracle中In子查询返回的结果不能超过1000条，使用exists为替代方案。</p>
</li>
<li><p>WHERE子句中的顺序<br>Oracle采用自下而上的顺序解析Where子句，根据这个原理,表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件写在Where子句的末尾。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> SQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[索引的工作原理及其种类]]></title>
      <url>/2016/12/28/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E7%A7%8D%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p>
<p><img src="https://raw.githubusercontent.com/sleepyyj/learngit/master/images/suoyin.png" alt="suoyin" title="suoyin"></p>
<p>图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
<p>创建索引可以大大提高系统的性能。</p>
<ul>
<li><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
</li>
<li><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p>
</li>
<li><p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
</li>
<li><p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p>
</li>
<li><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
</li>
</ul>
<p>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p>
<ul>
<li><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p>
</li>
<li><p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
</li>
<li><p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
</li>
</ul>
<p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
<p>同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：</p>
<ul>
<li><p>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
</li>
<li><p>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
</li>
<li><p>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p>
</li>
<li><p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
</li>
</ul>
<p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引是不允许其中任何两行具有相同索引值的索引。</p>
<p>当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 </p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 </p>
<p>###聚集索引<br>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p>
<p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>
<h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>到这里终于可以分析B-/+Tree索引的性能了。</p>
<p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
]]></content>
      
        <categories>
            
            <category> SQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
